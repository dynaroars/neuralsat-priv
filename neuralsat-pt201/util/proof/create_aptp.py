from beartype import beartype
import typing
import torch

@beartype
def _format_simple_assert(first: str, second: typing.Any, lt: bool) -> str:
    if lt:
        return f'(assert (<= {first} {second}))'
    return f'(assert (>= {first} {second}))'

@beartype
def _format_simple_declare(name: list | str, dtype: str) -> str:
    if isinstance(name, list):
        name = ' '.join(name)
    if dtype == 'Real':
        return f'(declare-const {name} {dtype})'
    return f'(declare-pwl {name} {dtype})'

@beartype
def _format_simple_proof(ap: list) -> str:
    # TODO: generalize to other activation
    def _format_node(value):
        assert isinstance(value, int) and value != 0, f'Invalid {value=}'
        if value > 0:
            return f'(>= N_{abs(value)} 0)'
        return f'(< N_{abs(value)} 0)'
    ret = [_format_node(_) for _ in ap]
    return f'(and {" ".join(ret)})'

@beartype
def create_aptp(
        proof: list, 
        lower: torch.Tensor, 
        upper: torch.Tensor, 
        cnf_cs: torch.Tensor, 
        cnf_rhs: torch.Tensor) -> str:
    assert len(cnf_cs) == len(cnf_rhs)
    assert torch.all(lower <= upper)
    
    declare_lines, input_lines, output_lines, hidden_lines = [], [], [], []
    declare_lines.extend([_format_simple_declare(f'X_{i}', 'Real') for i in range(len(lower.flatten()))])
    declare_lines.extend([_format_simple_declare(f'Y_{i}', 'Real') for i in range(len(cnf_cs[0]))])
    # TODO: generalize to other activation
    n_hiddens = max(abs(item) for path in proof for item in path)
    declare_lines.extend([_format_simple_declare(f'N_{i+1}', 'ReLU') for i in range(n_hiddens)])
    
    # input
    for i, (l, u) in enumerate(zip(lower.flatten(), upper.flatten())):
        input_lines.append(_format_simple_assert(f'X_{i}', u, lt=True))
        input_lines.append(_format_simple_assert(f'X_{i}', l, lt=False))
        
    # output
    for (cs, rhs) in zip(cnf_cs, cnf_rhs):
        l = [f'Y_{i}' for i, v in enumerate(cs) if v == 1]
        r = [f'Y_{i}' for i, v in enumerate(cs) if v == -1]
        if not len(l):
            l = ['0.0']
        if rhs != 0.0:
            r.append(rhs)
        assert len(l) == len(r) == 1
        output_lines.append(_format_simple_assert(l[0], r[0], lt=True))
    
    # hidden
    hidden_lines.extend([_format_simple_proof(p) for p in proof])
    
    # combine
    aptp_str = '; APTP generated by NeuralSAT\n\n'
    aptp_str += '\n'.join(declare_lines) + '\n\n'
    aptp_str += '\n'.join(input_lines) + '\n\n'
    aptp_str += '\n'.join(output_lines) + '\n\n'
    if hidden_lines:
        aptp_str += '(assert (or\n    ' + '\n    '.join(hidden_lines) + '))'
    return aptp_str

